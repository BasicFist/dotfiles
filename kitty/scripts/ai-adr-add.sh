#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════
# ADR Management - Add New Architecture Decision Record
# ═══════════════════════════════════════════════════════════

set -euo pipefail

# Source required libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/colors.sh"
source "${SCRIPT_DIR}/lib/errors.sh"
source "${SCRIPT_DIR}/lib/config.sh"

# Configuration
ADR_DIR="${AI_AGENTS_KB_DECISIONS:-$HOME/.ai-agents/knowledge/decisions}"
mkdir -p "$ADR_DIR"

usage() {
    cat <<EOF
Usage: ai-adr-add.sh [OPTIONS]

Create a new Architecture Decision Record (ADR).

OPTIONS:
  -t, --title TITLE         ADR title (required)
  -c, --context TEXT        Problem context
  -d, --decision TEXT       Decision description
  -i, --interactive         Interactive mode with prompts
  -h, --help               Show this help message

EXAMPLES:
  # Interactive mode
  ai-adr-add.sh --interactive

  # Quick mode
  ai-adr-add.sh --title "Use PostgreSQL for persistence"

EOF
}

# Get next ADR number
get_next_adr_number() {
    local max_num=0

    # Find existing ADRs
    if [[ -d "$ADR_DIR" ]]; then
        for file in "$ADR_DIR"/ADR-*.md; do
            if [[ -f "$file" ]]; then
                local num=$(basename "$file" | sed 's/ADR-\([0-9]*\).*/\1/')
                if [[ "$num" =~ ^[0-9]+$ ]] && [[ $num -gt $max_num ]]; then
                    max_num=$num
                fi
            fi
        done
    fi

    echo $((max_num + 1))
}

# Format ADR number with padding
format_adr_number() {
    printf "%04d" "$1"
}

# Create ADR from template
create_adr() {
    local number="$1"
    local title="$2"
    local context="${3:-To be documented}"
    local decision="${4:-To be documented}"
    local consequences_positive="${5:-To be documented}"
    local consequences_negative="${6:-To be documented}"
    local alternatives="${7:-To be documented}"

    local formatted_num=$(format_adr_number "$number")
    local filename="ADR-${formatted_num}-$(echo "$title" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-').md"
    local filepath="$ADR_DIR/$filename"

    # Create ADR file
    cat > "$filepath" <<EOF
# ADR-${formatted_num}: ${title}

**Status:** Proposed
**Date:** $(date +%Y-%m-%d)
**Decision Makers:** $(whoami)
**Supersedes:** N/A
**Superseded by:** N/A

## Context

${context}

## Decision

${decision}

## Consequences

### Positive

${consequences_positive}

### Negative

${consequences_negative}

## Alternatives Considered

${alternatives}

## Related Decisions

- None yet

## References

- TBD

---

*Generated by AI Agents ADR system on $(date -Iseconds)*
EOF

    echo "$filepath"
}

# Interactive mode
interactive_mode() {
    info_color "Creating new Architecture Decision Record"
    echo ""

    # Get title
    echo -n "ADR Title: "
    read -r title

    if [[ -z "$title" ]]; then
        error_color "❌ Title is required"
        exit 1
    fi

    # Get context
    info_color ""
    info_color "Context (problem statement, requirements, constraints)"
    info_color "Press Ctrl+D when done, or Enter twice for default"
    echo -n "> "

    local context=""
    local line
    local empty_line_count=0

    while IFS= read -r line; do
        if [[ -z "$line" ]]; then
            ((empty_line_count++))
            if [[ $empty_line_count -ge 2 ]]; then
                break
            fi
        else
            empty_line_count=0
        fi
        context+="$line"$'\n'
    done

    [[ -z "$context" ]] && context="To be documented"

    # Get decision
    info_color ""
    info_color "Decision (what was decided and why)"
    echo -n "> "
    read -r decision
    [[ -z "$decision" ]] && decision="To be documented"

    # Get consequences
    info_color ""
    info_color "Positive Consequences (benefits)"
    echo -n "> "
    read -r consequences_positive
    [[ -z "$consequences_positive" ]] && consequences_positive="To be documented"

    info_color ""
    info_color "Negative Consequences (trade-offs)"
    echo -n "> "
    read -r consequences_negative
    [[ -z "$consequences_negative" ]] && consequences_negative="To be documented"

    # Get alternatives
    info_color ""
    info_color "Alternatives Considered (optional)"
    echo -n "> "
    read -r alternatives
    [[ -z "$alternatives" ]] && alternatives="To be documented"

    # Create ADR
    local adr_number=$(get_next_adr_number)
    local filepath=$(create_adr "$adr_number" "$title" "$context" "$decision" "$consequences_positive" "$consequences_negative" "$alternatives")

    success_color ""
    success_color "✅ ADR created successfully!"
    info_color "   File: $filepath"
    info_color "   Number: ADR-$(format_adr_number $adr_number)"
    info_color ""
    info_color "Next steps:"
    info_color "  1. Edit: \$EDITOR $filepath"
    info_color "  2. Update status: ai-adr-update.sh $(format_adr_number $adr_number) --status Accepted"
    info_color "  3. Link related: ai-adr-link.sh $(format_adr_number $adr_number) --relates-to XXXX"
}

# Quick mode
quick_mode() {
    local title="$1"
    local context="${2:-To be documented}"
    local decision="${3:-To be documented}"

    local adr_number=$(get_next_adr_number)
    local filepath=$(create_adr "$adr_number" "$title" "$context" "$decision")

    success_color "✅ ADR-$(format_adr_number $adr_number) created: $filepath"
}

# Main function
main() {
    local title=""
    local context=""
    local decision=""
    local interactive=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--title)
                title="$2"
                shift 2
                ;;
            -c|--context)
                context="$2"
                shift 2
                ;;
            -d|--decision)
                decision="$2"
                shift 2
                ;;
            -i|--interactive)
                interactive=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                error_color "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Run appropriate mode
    if [[ "$interactive" == "true" ]]; then
        interactive_mode
    elif [[ -n "$title" ]]; then
        quick_mode "$title" "$context" "$decision"
    else
        error_color "❌ Title required. Use --title or --interactive"
        usage
        exit 1
    fi
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
