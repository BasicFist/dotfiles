# GitHub Issues for Tmux/Pair Programming System Improvement Roadmap

**Generated**: 2025-11-01
**Purpose**: Issue tracking for 6-month improvement roadmap
**Total Issues**: 35 across 5 phases

---

## How to Create These Issues

### Option 1: Manual Creation (Recommended for First Time)
1. Go to your GitHub repository
2. Click "Issues" → "New Issue"
3. Copy/paste each issue below
4. Add labels and milestone as indicated

### Option 2: GitHub CLI (Bulk Creation)
```bash
# Install gh CLI if not already installed
# sudo apt install gh

# Authenticate
gh auth login

# Create issues from this file (requires parsing script)
# Or create individually:
gh issue create --title "TITLE" --body "BODY" --label "LABELS" --milestone "MILESTONE"
```

### Option 3: Issues Template Files
Save each issue as `.github/ISSUE_TEMPLATE/phase-X-task-Y.md` and reference them.

---

## Labels to Create First

Create these labels in your repository (Settings → Labels):

- `priority: critical` (red)
- `priority: high` (orange)
- `priority: medium` (yellow)
- `priority: low` (green)
- `phase: 0-foundation` (blue)
- `phase: 1-completion` (blue)
- `phase: 2-advanced` (blue)
- `phase: 3-enterprise` (blue)
- `phase: 4-optimization` (blue)
- `type: bug` (red)
- `type: security` (red)
- `type: enhancement` (purple)
- `type: performance` (orange)
- `type: documentation` (cyan)
- `effort: small` (1-2 days)
- `effort: medium` (3-5 days)
- `effort: large` (1-2 weeks)

## Milestones to Create

1. **Phase 0: Foundation Stabilization** (due: +2 weeks)
2. **Phase 1: Completion & Polish** (due: +5 weeks)
3. **Phase 2: Advanced Features** (due: +9 weeks)
4. **Phase 3: Enterprise Features** (due: +13 weeks)
5. **Phase 4: Optimization & Scale** (due: +16 weeks)

---

# Phase 0: Foundation Stabilization (2 weeks)

## Issue #1: [P0] Fix ShellCheck Violations

**Labels**: `priority: high`, `phase: 0-foundation`, `type: bug`, `effort: small`
**Milestone**: Phase 0: Foundation Stabilization

### Description
Fix all 9 ShellCheck violations identified across 3 scripts to improve code quality and prevent potential bugs.

### Affected Files
- `scripts/modes/pair-programming.sh` (SC2188, line 30)
- `scripts/ai-pair-switch.sh` (SC2034, line 22)
- `scripts/ai-pair-observe.sh` (informational warnings)

### Tasks
- [ ] Fix SC2188: Empty redirection in `pair-programming.sh:30`
  ```bash
  # Current: > /tmp/ai-agents-shared.txt
  # Fixed: truncate -s 0 /tmp/ai-agents-shared.txt
  ```
- [ ] Fix SC2034: Remove unused NAVIGATOR variable or add validation in `ai-pair-switch.sh:22`
- [ ] Address informational SC1091 warnings (source file paths)
- [ ] Run `shellcheck scripts/**/*.sh` to verify all issues resolved
- [ ] Add shellcheck to CI/CD pipeline

### Acceptance Criteria
- ✅ `shellcheck scripts/**/*.sh` returns zero warnings
- ✅ All scripts execute without errors
- ✅ Existing tests continue to pass

### Estimated Effort
2-3 days

### References
- ShellCheck Wiki: https://www.shellcheck.net/wiki/
- Roadmap: `tmux_pair_programming_improvement_roadmap_20251101` (P0.1)

---

## Issue #2: [P0] Add Error Handling for JSON Operations

**Labels**: `priority: critical`, `phase: 0-foundation`, `type: bug`, `effort: medium`
**Milestone**: Phase 0: Foundation Stabilization

### Description
Add comprehensive error handling to all JSON operations using jq. Currently, jq failures fail silently, leading to corrupted state and confusing errors.

### Problem
```bash
# Current (unsafe):
DRIVER=$(jq -r '.driver' "$MODE_STATE")

# If jq fails or JSON is corrupted, DRIVER is empty string
# Script continues with invalid state
```

### Solution Pattern
```bash
# Safe pattern:
if ! state=$(jq -r '.driver, .navigator, .switches' "$MODE_STATE" 2>&1); then
    log_error "Failed to parse state file: $MODE_STATE"
    log_error "Error details: $state"
    safe_exit 1 "State file corrupted. Recovery: rm $MODE_STATE && restart mode"
fi
read -r DRIVER NAVIGATOR SWITCHES <<< "$state"
```

### Affected Files (15 scripts)
- `scripts/ai-pair-switch.sh`
- `scripts/ai-compete-*.sh` (3 files)
- `scripts/ai-consensus-*.sh` (5 files)
- `scripts/ai-debate-*.sh` (4 files)
- `scripts/ai-teach-*.sh` (5 files)

### Tasks
- [ ] Create error handling helper in `lib/errors.sh`:
  ```bash
  safe_jq() {
      local file="$1"
      shift
      local query="$@"

      if ! result=$(jq -r "$query" "$file" 2>&1); then
          log_error "safe_jq" "JSON parsing failed" "{\"file\": \"$file\", \"error\": \"$result\"}"
          return 1
      fi
      echo "$result"
  }
  ```
- [ ] Update all 15 scripts to use `safe_jq()` or inline error handling
- [ ] Add test case for corrupted JSON recovery
- [ ] Document error recovery procedures

### Acceptance Criteria
- ✅ All jq operations have error handling
- ✅ Corrupted state files trigger helpful error messages
- ✅ Test suite includes JSON corruption scenarios
- ✅ No script crashes on malformed JSON

### Estimated Effort
4 days

### References
- Roadmap section: P0.2

---

## Issue #3: [P0] Implement Secure Temp File Creation

**Labels**: `priority: critical`, `phase: 0-foundation`, `type: security`, `effort: medium`
**Milestone**: Phase 0: Foundation Stabilization

### Description
Replace predictable temp file paths with secure random paths and proper permissions to prevent security vulnerabilities in multi-user environments.

### Security Issues
1. **Predictable paths**: `/tmp/ai-mode-${SESSION}/` allows race conditions
2. **World-readable**: Default umask may allow other users to read sensitive data
3. **No ownership validation**: Attacker could pre-create directories
4. **Session hijacking**: Predictable names enable session interference

### Solution
Create `lib/secure-temp.sh` with secure temp file creation:

```bash
#!/usr/bin/env bash
# Secure temporary file and directory creation

create_secure_temp_dir() {
    local prefix="${1:-ai-mode}"
    local session="${2:-$$}"

    # Use mktemp for secure random directory
    local temp_base
    if ! temp_base=$(mktemp -d "/tmp/${prefix}-${session}-XXXXXXXX" 2>&1); then
        log_error "secure-temp" "Failed to create secure temp directory" "{\"error\": \"$temp_base\"}"
        return 1
    fi

    # Set restrictive permissions (owner only)
    chmod 700 "$temp_base" || {
        log_error "secure-temp" "Failed to set permissions"
        rm -rf "$temp_base"
        return 1
    }

    # Verify ownership
    if [[ $(stat -c%U "$temp_base" 2>/dev/null) != "$USER" ]]; then
        log_error "secure-temp" "Temp directory ownership mismatch"
        rm -rf "$temp_base"
        return 1
    fi

    # Store for cleanup
    SECURE_TEMP_DIRS+=("$temp_base")

    echo "$temp_base"
}

cleanup_secure_temps() {
    for dir in "${SECURE_TEMP_DIRS[@]}"; do
        [[ -d "$dir" ]] && rm -rf "$dir"
    done
}

trap cleanup_secure_temps EXIT
```

### Tasks
- [ ] Create `lib/secure-temp.sh` with helper functions
- [ ] Update all scripts using `/tmp/ai-mode-*` patterns
- [ ] Add cleanup trap handlers
- [ ] Set `umask 077` in all scripts
- [ ] Add test for secure temp file creation
- [ ] Document security improvements

### Scripts to Update
- `scripts/modes/pair-programming.sh`
- `scripts/ai-agents-tui.sh`
- All mode starter scripts
- Session management scripts

### Acceptance Criteria
- ✅ No predictable temp file paths remain
- ✅ All temp files have 700 permissions
- ✅ Ownership validation passes
- ✅ Cleanup on exit works correctly
- ✅ Multi-user test shows isolation

### Estimated Effort
5 days

### References
- Roadmap section: P0.3
- Security findings in session memory

---

## Issue #4: [P0] Add File Locking for Concurrent State Updates

**Labels**: `priority: high`, `phase: 0-foundation`, `type: bug`, `effort: medium`
**Milestone**: Phase 0: Foundation Stabilization

### Description
Implement file locking mechanism to prevent race conditions when multiple processes update state files concurrently.

### Problem
Current code in `ai-pair-switch.sh`:
```bash
jq ... "$MODE_STATE" > "${MODE_STATE}.tmp" && mv "${MODE_STATE}.tmp" "$MODE_STATE"
```

If two processes run simultaneously, one will overwrite the other's changes, causing lost updates.

### Solution
Add to `lib/common.sh`:

```bash
acquire_lock() {
    local lock_file="$1"
    local timeout="${2:-10}"
    local elapsed=0

    # Use mkdir for atomic lock creation
    while ! mkdir "$lock_file.lock" 2>/dev/null; do
        # Check for stale lock
        if [[ -f "$lock_file.lock/pid" ]]; then
            local lock_pid=$(cat "$lock_file.lock/pid")
            if ! kill -0 "$lock_pid" 2>/dev/null; then
                # Process dead, remove stale lock
                rm -rf "$lock_file.lock"
                continue
            fi
        fi

        sleep 0.1
        elapsed=$((elapsed + 1))
        if [[ $elapsed -ge $((timeout * 10)) ]]; then
            log_error "locking" "Failed to acquire lock: $lock_file"
            return 1
        fi
    done

    # Store PID for stale lock detection
    echo $$ > "$lock_file.lock/pid"
    log_debug "locking" "Lock acquired: $lock_file"
}

release_lock() {
    local lock_file="$1"
    rm -rf "$lock_file.lock" 2>/dev/null || true
    log_debug "locking" "Lock released: $lock_file"
}
```

### Usage Pattern
```bash
acquire_lock "$MODE_STATE" || safe_exit 1 "Could not acquire state lock"

# Critical section - update state
jq ... "$MODE_STATE" > "${MODE_STATE}.tmp"
mv "${MODE_STATE}.tmp" "$MODE_STATE"

release_lock "$MODE_STATE"
```

### Tasks
- [ ] Implement locking functions in `lib/common.sh`
- [ ] Update all state-writing scripts (15+ files)
- [ ] Add stale lock detection and cleanup
- [ ] Create test for concurrent state updates
- [ ] Document locking protocol
- [ ] Add lock timeout configuration

### Acceptance Criteria
- ✅ All state updates use locking
- ✅ Concurrent update test passes (10 parallel updates, no data loss)
- ✅ Stale locks are detected and cleaned
- ✅ Lock timeouts work correctly
- ✅ Performance impact <100ms per operation

### Estimated Effort
3 days

### Related Issues
- Depends on: #2 (error handling)

---

## Issue #5: [P0] Centralize Configuration Constants

**Labels**: `priority: high`, `phase: 0-foundation`, `type: enhancement`, `effort: small`
**Milestone**: Phase 0: Foundation Stabilization

### Description
Move all hard-coded paths and magic numbers into centralized configuration to improve maintainability and flexibility.

### Hard-coded Values Found
- `/tmp/ai-agents-shared.txt` - repeated 40+ times
- `/tmp/ai-mode-${SESSION}/` - state directory template
- `1800` - switch interval in seconds
- `~/.ai-agents/` - KB root path
- Various timeout values

### Solution
Extend `lib/config.sh` default configuration:

```json
{
  "version": "1.0.0",
  "system": {
    "shared_file": "/tmp/ai-agents-shared.txt",
    "state_dir_template": "/tmp/ai-mode-{session}",
    "switch_interval": 1800,
    "cleanup_on_exit": true
  },
  "paths": {
    "kb_root": "~/.ai-agents",
    "kb_docs": "~/.ai-agents/knowledge/docs",
    "kb_snippets": "~/.ai-agents/knowledge/snippets",
    "kb_decisions": "~/.ai-agents/knowledge/decisions",
    "kb_patterns": "~/.ai-agents/knowledge/patterns",
    "sessions": "~/.ai-agents/sessions",
    "snapshots": "~/.ai-agents/snapshots",
    "lessons": "~/.ai-agents/lessons",
    "logs": "~/.ai-agents/logs",
    "backups": "~/.ai-agents/backups",
    "plugins": "~/.ai-agents/plugins"
  },
  "timeouts": {
    "dialog": 300,
    "operation": 60,
    "lock": 10
  },
  "modes": {
    "pair": {
      "switch_interval": 1800,
      "auto_save": true
    },
    "debate": {
      "rounds": 4,
      "time_per_round": 600
    },
    "teaching": {
      "mastery_threshold": 80,
      "exercise_count": 5
    }
  }
}
```

### Add Helper Functions
```bash
# Get configured path with ~ expansion
get_path() {
    local key="$1"
    local path=$(get_config "paths.$key")
    echo "${path/#\~/$HOME}"
}

# Get mode-specific config
get_mode_config() {
    local mode="$1"
    local key="$2"
    local default="${3:-}"
    get_config "modes.${mode}.${key}" "$default"
}

# Get system setting
get_system_config() {
    local key="$1"
    local default="${2:-}"
    get_config "system.${key}" "$default"
}
```

### Tasks
- [ ] Extend `DEFAULT_CONFIG` in `lib/config.sh`
- [ ] Add helper functions for path/mode/system config access
- [ ] Create migration script to update user configs
- [ ] Replace all hard-coded values (grep for patterns)
- [ ] Update documentation
- [ ] Add configuration validation tests

### Acceptance Criteria
- ✅ Zero hard-coded paths in scripts
- ✅ All magic numbers configurable
- ✅ Helper functions tested
- ✅ Config validation passes
- ✅ Backwards compatibility maintained

### Estimated Effort
3 days

### References
- Roadmap section: P0.4

---

## Issue #6: [P0] Add Dependency Checks at Script Startup

**Labels**: `priority: high`, `phase: 0-foundation`, `type: enhancement`, `effort: small`
**Milestone**: Phase 0: Foundation Stabilization

### Description
Add validation for required dependencies (jq, tmux, dialog, fzf) at script startup to provide clear error messages instead of cryptic failures.

### Current Problem
Scripts assume dependencies exist. When missing, users get confusing errors like:
```
line 42: jq: command not found
```

### Solution
Create `lib/dependencies.sh`:

```bash
#!/usr/bin/env bash
# Dependency validation and version checking

declare -A REQUIRED_DEPS=(
    [jq]="1.5"
    [tmux]="2.0"
)

declare -A OPTIONAL_DEPS=(
    [fzf]="0.20.0"
    [bat]="0.12.0"
    [dialog]=""
    [whiptail]=""
)

check_dependency() {
    local cmd="$1"
    local min_version="${2:-}"

    if ! command -v "$cmd" &>/dev/null; then
        return 1
    fi

    # Version check if specified
    if [[ -n "$min_version" ]]; then
        local current_version=$("$cmd" --version 2>/dev/null | head -1 | grep -oP '\d+\.\d+(\.\d+)?' | head -1)
        if [[ -n "$current_version" ]]; then
            if ! version_gte "$current_version" "$min_version"; then
                return 2  # Installed but too old
            fi
        fi
    fi

    return 0
}

check_dependencies() {
    local missing=()
    local old_version=()

    # Check required
    for dep in "${!REQUIRED_DEPS[@]}"; do
        local min_ver="${REQUIRED_DEPS[$dep]}"
        if ! check_dependency "$dep" "$min_ver"; then
            case $? in
                1) missing+=("$dep") ;;
                2) old_version+=("$dep (need $min_ver+)") ;;
            esac
        fi
    done

    # Report errors
    if [[ ${#missing[@]} -gt 0 ]]; then
        error_color "❌ Missing required dependencies:"
        for dep in "${missing[@]}"; do
            echo "  - $dep"
        done
        echo ""
        echo "Install with: sudo apt install ${missing[*]}"
        return 1
    fi

    if [[ ${#old_version[@]} -gt 0 ]]; then
        warning_color "⚠️  Outdated dependencies:"
        for dep in "${old_version[@]}"; do
            echo "  - $dep"
        done
    fi

    return 0
}

# Version comparison helper
version_gte() {
    local v1="$1"
    local v2="$2"
    printf '%s\n%s\n' "$v2" "$v1" | sort -V -C
}

export -f check_dependency
export -f check_dependencies
export -f version_gte
```

### Tasks
- [ ] Create `lib/dependencies.sh`
- [ ] Add dependency check to main scripts (TUI, mode launchers)
- [ ] Provide installation instructions for missing deps
- [ ] Add optional dependency warnings (fzf, bat)
- [ ] Test on clean system without dependencies
- [ ] Document required/optional dependencies

### Acceptance Criteria
- ✅ Clear error message for missing dependencies
- ✅ Installation instructions provided
- ✅ Version checking works for major tools
- ✅ Optional dependencies don't block execution
- ✅ Documentation updated with dependency list

### Estimated Effort
2 days

---

# Phase 1: Completion & Polish (3 weeks)

## Issue #7: [P1] Complete fzf Integration - Mode Launcher Enhancement

**Labels**: `priority: medium`, `phase: 1-completion`, `type: enhancement`, `effort: small`
**Milestone**: Phase 1: Completion & Polish

### Description
Enhance existing `ai-mode-fzf.sh` with mode statistics, recently used tracking, and favorites support for improved UX.

### Current State
Basic mode launcher exists but lacks context and personalization.

### Enhancements
1. **Mode Statistics**
   - Times used (counter)
   - Last used timestamp
   - Average session duration
   - Success/failure rate

2. **Recently Used**
   - Show last 5 modes with timestamp
   - Quick access via hotkey

3. **Favorites**
   - Star/unstar modes
   - Sort favorites to top

### Implementation
```bash
# Store stats in ~/.ai-agents/mode-stats.json
{
  "pair": {
    "count": 42,
    "last_used": "2025-11-01T10:30:00",
    "avg_duration": 3600,
    "success_rate": 0.95,
    "favorite": true
  },
  ...
}

# Preview format
preview_mode() {
    local mode="$1"
    local stats=$(jq -r ".$mode" ~/.ai-agents/mode-stats.json)

    cat <<EOF
Mode: ${mode}
Used: ${count} times
Last: ${last_used}
Avg Duration: ${avg_duration}s
Success Rate: ${success_rate}%
$(if [[ $favorite == true ]]; then echo "⭐ Favorite"; fi)

${mode_description}
EOF
}
```

### Tasks
- [ ] Create mode stats tracking
- [ ] Add stats display to preview
- [ ] Implement favorite toggling
- [ ] Add recently used sorting
- [ ] Update keyboard shortcuts documentation
- [ ] Add tests for stats tracking

### Acceptance Criteria
- ✅ Mode statistics tracked accurately
- ✅ Favorites sort to top
- ✅ Recently used visible in preview
- ✅ Stats persist across sessions

### Estimated Effort
2 days

---

## Issue #8: [P1] Complete fzf Integration - ADR Browser

**Labels**: `priority: medium`, `phase: 1-completion`, `type: enhancement`, `effort: small`
**Milestone**: Phase 1: Completion & Polish

### Description
Create `ai-adr-browse-fzf.sh` for browsing Architecture Decision Records with fuzzy search, filtering, and relationship visualization.

### Features
1. **Fuzzy Search** across titles, context, decisions
2. **Status Filtering** (Accepted, Proposed, Deprecated, Superseded)
3. **Date Range** filtering
4. **Preview** with syntax highlighting
5. **Related ADRs** shown in preview
6. **Quick Actions**: edit, supersede, link

### Implementation
```bash
#!/usr/bin/env bash
# ADR Browser with fzf

set -euo pipefail
source "$(dirname "$0")/lib/config.sh"
source "$(dirname "$0")/lib/colors.sh"

ADR_DIR=$(get_path "kb_decisions")

browse_adrs() {
    local status_filter="${1:-all}"

    # Build ADR list with metadata
    local adr_list=$(find "$ADR_DIR" -name "ADR-*.md" -type f | while read -r file; do
        local number=$(basename "$file" | grep -oP 'ADR-\K\d+')
        local title=$(grep "^# ADR-" "$file" | head -1 | sed 's/# ADR-[0-9]*: //')
        local status=$(grep "^\*\*Status:\*\*" "$file" | grep -oP '(?<=\*\*Status:\*\* )\w+')
        local date=$(grep "^\*\*Date:\*\*" "$file" | grep -oP '\d{4}-\d{2}-\d{2}')

        # Filter by status
        if [[ "$status_filter" != "all" && "$status" != "$status_filter" ]]; then
            continue
        fi

        printf "%s\t%s\t%s\t%s\t%s\n" "$number" "$status" "$date" "$title" "$file"
    done | sort -rn)

    # fzf with preview
    local selected=$(echo "$adr_list" | fzf \
        --delimiter='\t' \
        --with-nth=1,2,3,4 \
        --preview='bat --style=numbers,grid --color=always {5}' \
        --preview-window='right:60%:wrap' \
        --header='ADRs | Ctrl-E: Edit | Ctrl-S: Supersede | Ctrl-L: Link' \
        --bind='ctrl-e:execute($EDITOR {5})' \
        --bind='ctrl-s:execute(./scripts/ai-adr-supersede.sh {5})' \
        --bind='ctrl-l:execute(./scripts/ai-adr-link.sh {5})')

    if [[ -n "$selected" ]]; then
        local file=$(echo "$selected" | cut -f5)
        $EDITOR "$file"
    fi
}

# Parse arguments
status_filter="all"
while [[ $# -gt 0 ]]; do
    case $1 in
        --status) status_filter="$2"; shift 2 ;;
        *) shift ;;
    esac
done

browse_adrs "$status_filter"
```

### Tasks
- [ ] Create `ai-adr-browse-fzf.sh`
- [ ] Add status filtering
- [ ] Implement related ADR detection
- [ ] Add keyboard shortcuts for quick actions
- [ ] Create helper scripts (supersede, link)
- [ ] Add to TUI menu
- [ ] Document usage

### Acceptance Criteria
- ✅ Search across all ADR fields
- ✅ Status filtering works
- ✅ Preview shows related ADRs
- ✅ Quick actions functional
- ✅ Integration with TUI

### Estimated Effort
2 days

---

## Issue #9: [P1] Implement ADR Support - Core Scripts

**Labels**: `priority: medium`, `phase: 1-completion`, `type: enhancement`, `effort: medium`
**Milestone**: Phase 1: Completion & Polish

### Description
Implement Architecture Decision Record (ADR) support with creation, update, and lifecycle management scripts as specified in ENHANCEMENT-ROADMAP.md.

### Core Scripts to Create

1. **ai-adr-add.sh** - Create new ADR
2. **ai-adr-update.sh** - Update status, add references
3. **ai-adr-supersede.sh** - Mark ADR as superseded by another
4. **ai-adr-link.sh** - Link related ADRs
5. **ai-adr-graph.sh** - Visualize decision dependencies

### ADR Template
```markdown
# ADR-{number}: {title}

**Status:** Proposed | Accepted | Deprecated | Superseded
**Date:** {YYYY-MM-DD}
**Decision Makers:** {agents/users}
**Supersedes:** ADR-{number} (if applicable)
**Superseded by:** ADR-{number} (if applicable)

## Context

{Problem statement, requirements, constraints}

## Decision

{What was decided and why}

## Consequences

### Positive
- {benefit 1}
- {benefit 2}

### Negative
- {trade-off 1}
- {trade-off 2}

## Alternatives Considered

1. **{Alternative 1}**
   - Pros: ...
   - Cons: ...
   - Rejected because: ...

## Related Decisions
- ADR-{number}: {title}

## References
- {links, docs, discussions}

---

*Generated by AI Agents ADR system*
```

### Tasks
- [ ] Create ADR directory structure
- [ ] Implement `ai-adr-add.sh` with interactive prompts
- [ ] Implement `ai-adr-update.sh` for status changes
- [ ] Implement `ai-adr-supersede.sh` for lifecycle management
- [ ] Implement `ai-adr-link.sh` for relationship management
- [ ] Implement `ai-adr-graph.sh` for visualization (optional: use graphviz)
- [ ] Add ADR validation
- [ ] Index ADRs in KB search
- [ ] Add to TUI menu
- [ ] Document ADR workflow

### Acceptance Criteria
- ✅ ADRs follow standard template
- ✅ Auto-numbering works correctly
- ✅ Status lifecycle tracked
- ✅ Relationships maintained bidirectionally
- ✅ ADRs searchable via KB
- ✅ Documentation complete

### Estimated Effort
4 days

### References
- ENHANCEMENT-ROADMAP.md sections 1.1-1.7

---

## Issue #10: [P1] Complete Test Suite - Add Comprehensive Tests

**Labels**: `priority: high`, `phase: 1-completion`, `type: enhancement`, `effort: medium`
**Milestone**: Phase 1: Completion & Polish

### Description
Complete stub tests in `ai-self-test.sh` and add comprehensive test coverage for critical functionality.

### Current Coverage: ~60%
### Target Coverage: 80%

### Tests to Implement

1. **Concurrent State Updates** (test_concurrent_state_updates)
   - Spawn 10 parallel processes updating same state
   - Verify no lost updates with file locking
   - Verify final state consistency

2. **Input Sanitization Comprehensive** (test_input_sanitization_comprehensive)
   - SQL injection patterns
   - Command injection patterns
   - Path traversal patterns
   - Verify all dangerous inputs blocked

3. **Error Recovery** (test_error_recovery)
   - Corrupted JSON handling
   - Missing dependency graceful failure
   - Network timeout recovery
   - Disk full scenarios

4. **Session Persistence** (test_session_persistence)
   - Session save/restore cycle
   - Metadata integrity
   - Large session handling (100+ panes)

5. **KB Index Performance** (test_kb_index_performance)
   - Index 1000+ documents
   - Search performance <100ms
   - Index rebuild after changes

6. **Configuration Migration** (test_config_migration)
   - Upgrade from v1.0 to v2.0
   - Preserve custom settings
   - Handle incompatible changes

7. **Multi-user Isolation** (test_multi_user_isolation)
   - Simulate 2 users
   - Verify session isolation
   - Verify temp file separation

8. **Memory Leak Detection** (test_memory_leaks)
   - Run long-lived process (5 min)
   - Monitor memory growth
   - Verify cleanup

9. **Unicode Handling** (test_unicode_support)
   - Test with emoji, CJK characters
   - Verify display and storage

10. **Large File Handling** (test_large_file_handling)
    - KB with 10,000+ documents
    - Session with 100MB+ data
    - Performance remains acceptable

### Tasks
- [ ] Implement 10 comprehensive tests
- [ ] Add performance benchmarking tests
- [ ] Create test data generators
- [ ] Add test report formatting
- [ ] Set up code coverage measurement (kcov)
- [ ] Document test procedures
- [ ] Add tests to CI/CD

### Acceptance Criteria
- ✅ All new tests pass
- ✅ Test coverage >80%
- ✅ Performance tests establish baselines
- ✅ Test report generation works
- ✅ CI/CD runs tests automatically

### Estimated Effort
4 days

---

## Issue #11: [P1] Documentation Consolidation

**Labels**: `priority: medium`, `phase: 1-completion`, `type: documentation`, `effort: small`
**Milestone**: Phase 1: Completion & Polish

### Description
Consolidate and organize documentation with master index, architecture guide, and API reference.

### Files to Create

1. **docs/README.md** - Master index
2. **docs/ARCHITECTURE.md** - System design
3. **docs/API.md** - Script interfaces
4. **docs/TESTING.md** - Test guide
5. **docs/TROUBLESHOOTING.md** - Common issues

### Documentation Standards

**Inline Function Documentation Pattern**:
```bash
# Brief description of what this function does
#
# Args:
#   $1 - First parameter description
#   $2 - Second parameter (optional, default: value)
#
# Returns:
#   0 on success, 1 on failure
#
# Side effects:
#   - Creates files in /tmp
#   - Modifies global variable STATE
#
# Example:
#   my_function "arg1" "arg2"
#
my_function() {
    ...
}
```

### Tasks
- [ ] Create master documentation index
- [ ] Write architecture guide with diagrams
- [ ] Document all public script APIs
- [ ] Create testing guide
- [ ] Compile troubleshooting guide
- [ ] Add inline docs to all library functions
- [ ] Validate all documentation links
- [ ] Generate API reference from code

### Acceptance Criteria
- ✅ Master index links to all docs
- ✅ Architecture guide accurate
- ✅ All public functions documented
- ✅ Zero broken links
- ✅ Examples tested and working

### Estimated Effort
2 days

---

# Phase 2: Advanced Features (4 weeks)

## Issue #12: [P2] Implement Structured Logging System

**Labels**: `priority: high`, `phase: 2-advanced`, `type: enhancement`, `effort: medium`
**Milestone**: Phase 2: Advanced Features

### Description
Create comprehensive structured logging system with JSON format, log levels, rotation, and integration across all scripts.

### Implementation Details in Roadmap
See roadmap section P2.1 for complete implementation.

### Key Features
- JSON structured logs
- Log levels (DEBUG, INFO, WARN, ERROR, FATAL)
- Automatic log rotation (10MB threshold)
- Log aggregation
- Query capabilities

### Tasks
- [ ] Create `lib/logging.sh` with structured logging functions
- [ ] Add log level configuration
- [ ] Implement log rotation
- [ ] Update all scripts to use structured logging
- [ ] Create log query tool
- [ ] Add logging documentation

### Estimated Effort
6 days

---

## Issue #13: [P2] Performance Optimization - JSON Query Caching

**Labels**: `priority: medium`, `phase: 2-advanced`, `type: performance`, `effort: medium`
**Milestone**: Phase 2: Advanced Features

### Description
Implement JSON query caching to reduce jq invocations by >60% and improve performance.

### Implementation Details in Roadmap
See roadmap section P2.2 for complete implementation.

### Expected Improvements
- 60% reduction in jq calls
- 30% faster overall performance
- Lower CPU usage

### Tasks
- [ ] Create `lib/json-cache.sh`
- [ ] Implement cache with TTL
- [ ] Add cache invalidation
- [ ] Update scripts to use cached queries
- [ ] Benchmark performance improvement

### Estimated Effort
3 days

---

## Issue #14: [P2] Performance Optimization - Batch Write System

**Labels**: `priority: medium`, `phase: 2-advanced`, `type: performance`, `effort: small`
**Milestone**: Phase 2: Advanced Features

### Description
Implement batch writing system to reduce I/O operations for frequently written files.

### Implementation Details in Roadmap
See roadmap section P2.2 for complete implementation.

### Tasks
- [ ] Create `lib/batch-writer.sh`
- [ ] Implement write buffering
- [ ] Add automatic flushing
- [ ] Update high-frequency write operations
- [ ] Add flush on exit trap

### Estimated Effort
2 days

---

## Issue #15: [P2] Remote Session Support - Infrastructure

**Labels**: `priority: low`, `phase: 2-advanced`, `type: enhancement`, `effort: large`
**Milestone**: Phase 2: Advanced Features

### Description
Enable collaboration across machines with SSH tunneling, state synchronization, and conflict resolution.

### Implementation Details in Roadmap
See roadmap section P2.3 for complete implementation.

### Features
- SSH tunnel for tmux sharing
- State file synchronization
- Conflict resolution
- Remote session management

### Tasks
- [ ] Create `ai-remote-init.sh`
- [ ] Create `ai-remote-connect.sh`
- [ ] Implement state sync mechanism
- [ ] Add conflict resolution
- [ ] Test with 2+ machines
- [ ] Document remote setup

### Estimated Effort
7 days

---

## Issue #16: [P2] Metrics & Analytics System

**Labels**: `priority: medium`, `phase: 2-advanced`, `type: enhancement`, `effort: medium`
**Milestone**: Phase 2: Advanced Features

### Description
Add comprehensive metrics tracking with counters, gauges, histograms, and simple dashboard.

### Implementation Details in Roadmap
See roadmap section P2.4 for complete implementation.

### Metrics to Track
- Mode usage counters
- Active sessions (gauge)
- Command execution duration (histogram)
- KB search performance
- Error rates

### Tasks
- [ ] Create `lib/metrics.sh`
- [ ] Implement counter, gauge, histogram types
- [ ] Add metrics collection to all modes
- [ ] Create simple CLI dashboard
- [ ] Add metrics documentation

### Estimated Effort
4 days

---

# Phase 3: Enterprise Features (4 weeks)

## Issue #17: [P3] Multi-tenancy & RBAC Implementation

**Labels**: `priority: low`, `phase: 3-enterprise`, `type: enhancement`, `effort: large`
**Milestone**: Phase 3: Enterprise Features

### Description
Implement Role-Based Access Control for multi-user environments.

### Implementation Details in Roadmap
See roadmap section P3.1 for complete implementation.

### Roles
- admin: Full access
- user: Standard access
- readonly: Read-only access

### Tasks
- [ ] Create `lib/rbac.sh`
- [ ] Define role permissions
- [ ] Add permission checks to all sensitive operations
- [ ] Create user management tools
- [ ] Test multi-user scenarios
- [ ] Document RBAC system

### Estimated Effort
7 days

---

## Issue #18: [P3] Compliance & Audit Logging

**Labels**: `priority: low`, `phase: 3-enterprise`, `type: security`, `effort: medium`
**Milestone**: Phase 3: Enterprise Features

### Description
Add tamper-evident audit logging for compliance requirements (SOC2, GDPR).

### Implementation Details in Roadmap
See roadmap section P3.2 for complete implementation.

### Features
- Tamper-evident logs (SHA256 hashes)
- Append-only audit files
- Compliance reporting
- Audit log analysis

### Tasks
- [ ] Create `lib/audit.sh`
- [ ] Implement audit log creation
- [ ] Add audit entries to critical operations
- [ ] Create compliance report generator
- [ ] Test audit integrity
- [ ] Document audit procedures

### Estimated Effort
5 days

---

## Issue #19: [P3] Backup & Disaster Recovery

**Labels**: `priority: medium`, `phase: 3-enterprise`, `type: enhancement`, `effort: medium`
**Milestone**: Phase 3: Enterprise Features

### Description
Automated backup and recovery system with full/incremental backups and verification.

### Implementation Details in Roadmap
See roadmap section P3.3 for complete implementation.

### Features
- Full and incremental backups
- Checksum verification
- Automated restore
- Backup scheduling

### Tasks
- [ ] Create `ai-backup-create.sh`
- [ ] Create `ai-backup-restore.sh`
- [ ] Create `ai-backup-verify.sh`
- [ ] Add automated backup scheduling
- [ ] Test disaster recovery scenarios
- [ ] Document backup procedures

### Estimated Effort
4 days

---

## Issue #20: [P3] Plugin System Implementation

**Labels**: `priority: low`, `phase: 3-enterprise`, `type: enhancement`, `effort: large`
**Milestone**: Phase 3: Enterprise Features

### Description
Extensible plugin architecture with hook system for custom extensions.

### Implementation Details in Roadmap
See roadmap section P3.4 for complete implementation.

### Plugin Structure
```
plugins/
├── registry.json
└── my-plugin/
    ├── plugin.json
    ├── install.sh
    └── hooks/
        ├── mode-start
        └── mode-stop
```

### Tasks
- [ ] Create `lib/plugin-manager.sh`
- [ ] Define plugin API
- [ ] Implement hook system
- [ ] Create 5 example plugins
- [ ] Add plugin discovery
- [ ] Document plugin development

### Estimated Effort
6 days

---

# Phase 4: Optimization & Scale (3 weeks)

## Issue #21: [P4] Resource Management System

**Labels**: `priority: medium`, `phase: 4-optimization`, `type: performance`, `effort: medium`
**Milestone**: Phase 4: Optimization & Scale

### Description
Implement resource monitoring, limits, and cleanup automation.

### Features
- Memory usage monitoring
- Process pooling
- Background job scheduling
- Automatic cleanup (logs, cache, temps)

### Tasks
- [ ] Add memory monitoring
- [ ] Implement process pooling
- [ ] Create cleanup automation
- [ ] Add resource limits
- [ ] Test under load

### Estimated Effort
5 days

---

## Issue #22: [P4] Advanced Search with Full-Text Index

**Labels**: `priority: medium`, `phase: 4-optimization`, `type: enhancement`, `effort: medium`
**Milestone**: Phase 4: Optimization & Scale

### Description
Implement full-text search with relevance ranking, fuzzy matching, and search suggestions.

### Features
- Full-text indexing
- Relevance ranking
- Typo tolerance
- Search suggestions
- Search analytics

### Tasks
- [ ] Research indexing solutions (whoosh, meilisearch)
- [ ] Implement indexer
- [ ] Add relevance scoring
- [ ] Create search suggestions
- [ ] Benchmark performance

### Estimated Effort
5 days

---

## Issue #23: [P4] CI/CD Pipeline Setup

**Labels**: `priority: high`, `phase: 4-optimization`, `type: enhancement`, `effort: medium`
**Milestone**: Phase 4: Optimization & Scale

### Description
Set up GitHub Actions workflow for automated testing, benchmarking, and quality checks.

### Implementation Details in Roadmap
See roadmap section P4.3 for complete workflow.

### Pipeline Stages
1. Dependency installation
2. ShellCheck linting
3. Unit tests
4. Integration tests
5. Performance benchmarks
6. Test report upload

### Tasks
- [ ] Create `.github/workflows/test.yml`
- [ ] Add test job
- [ ] Add lint job
- [ ] Add benchmark job
- [ ] Configure artifact upload
- [ ] Add status badge to README

### Estimated Effort
2 days

---

# Meta Issues

## Issue #24: [META] Phase 0 Completion Checklist

**Labels**: `priority: critical`, `phase: 0-foundation`, `type: meta`
**Milestone**: Phase 0: Foundation Stabilization

### Description
Track overall completion of Phase 0: Foundation Stabilization.

### Completion Criteria
- [ ] All ShellCheck violations fixed (#1)
- [ ] Error handling added to all JSON ops (#2)
- [ ] Secure temp file creation implemented (#3)
- [ ] File locking operational (#4)
- [ ] Configuration constants centralized (#5)
- [ ] Dependency checks added (#6)
- [ ] All Phase 0 tests passing
- [ ] Security audit shows no critical issues
- [ ] Documentation updated

### Phase 0 Success Metrics
- ✅ Zero ShellCheck warnings
- ✅ 100% JSON error handling
- ✅ 700 permissions on temp files
- ✅ No race conditions in tests
- ✅ Zero hard-coded paths

---

## Issue #25: [META] Phase 1 Completion Checklist

**Labels**: `priority: high`, `phase: 1-completion`, `type: meta`
**Milestone**: Phase 1: Completion & Polish

### Description
Track overall completion of Phase 1: Completion & Polish.

### Completion Criteria
- [ ] fzf integration 100% complete (#7, #8)
- [ ] ADR support functional (#9)
- [ ] Test coverage >80% (#10)
- [ ] Documentation consolidated (#11)
- [ ] All Phase 1 tests passing
- [ ] User acceptance testing complete

### Phase 1 Success Metrics
- ✅ All fzf features working
- ✅ 10+ ADRs created and tested
- ✅ Test coverage measured >80%
- ✅ Zero broken documentation links

---

## Issue #26: [META] Create Project Board

**Labels**: `priority: high`, `type: meta`, `effort: small`

### Description
Set up GitHub Project board for tracking roadmap progress.

### Board Columns
1. Backlog
2. Ready
3. In Progress
4. In Review
5. Done

### Views to Create
1. **By Phase** - Group by milestone
2. **By Priority** - Sort by priority label
3. **Timeline** - Gantt chart view
4. **My Tasks** - Filtered by assignee

### Tasks
- [ ] Create project board
- [ ] Add all issues to board
- [ ] Configure automation rules
- [ ] Set up views
- [ ] Document board usage

### Estimated Effort
1 hour

---

## Issue #27: [META] Establish Code Review Process

**Labels**: `priority: high`, `type: meta`, `effort: small`

### Description
Define and document code review process for all changes.

### Review Checklist
- [ ] Code follows project style
- [ ] All tests pass
- [ ] ShellCheck clean
- [ ] Documentation updated
- [ ] Security considerations addressed
- [ ] Performance impact assessed
- [ ] Backwards compatibility maintained

### Process
1. Create feature branch
2. Implement changes
3. Run `./scripts/ai-self-test.sh`
4. Create pull request
5. Request review
6. Address feedback
7. Merge to main

### Tasks
- [ ] Create CONTRIBUTING.md
- [ ] Define review checklist
- [ ] Set up PR template
- [ ] Document process
- [ ] Configure branch protection

### Estimated Effort
2 hours

---

# Summary

## Issue Count by Phase
- **Phase 0**: 6 issues (2 weeks)
- **Phase 1**: 5 issues (3 weeks)
- **Phase 2**: 5 issues (4 weeks)
- **Phase 3**: 4 issues (4 weeks)
- **Phase 4**: 3 issues (3 weeks)
- **Meta**: 3 issues (ongoing)
- **Total**: 26 issues

## Priority Breakdown
- **Critical**: 2 issues
- **High**: 10 issues
- **Medium**: 11 issues
- **Low**: 3 issues

## Effort Breakdown
- **Small** (1-2 days): 8 issues
- **Medium** (3-5 days): 13 issues
- **Large** (1-2 weeks): 5 issues

## Quick Start
1. Create labels and milestones (10 min)
2. Create Phase 0 issues first (#1-#6)
3. Set up project board (#26)
4. Begin with issue #1 (ShellCheck fixes)

---

**Generated by**: Comprehensive improvement analysis session
**Date**: 2025-11-01
**Roadmap Reference**: `tmux_pair_programming_improvement_roadmap_20251101` (Serena MCP memory)
